import (
	"std.um"

	"chunk.um"
	"value.um"
	"object.um"
	"common.um"
	"debug.um"
	"compiler.um"
)

type InterpretResult* = enum {
	Ok
	CompileError
	RuntimeError
}

const FRAMES_MAX* = 64
const STACK_MAX* = FRAMES_MAX * common::UINT8_COUNT

// TODO: encode some other way
type CallFrame = struct {
	function: ^object::Function
	ip: uint
	slots: uint
}

type VM = struct {
	frames: [FRAMES_MAX]CallFrame
	frameCount: uint
	
	ip: uint
	stack: [STACK_MAX]value::Value
	stackTop: uint
	globals: map[str]value::Value
}

var vm: VM

fn clock(args: uint, stack: []value::Value, base: uint): value::Value {
	return value::Number(std::clock())
}

fn resetStack() {
	vm.stackTop = 0
	vm.frameCount = 0
}

fn runtimeError(msg: str): InterpretResult {
	fprintf(std::stderr(), "%s\n", msg)

	for i := int(vm.frameCount - 1); i >= 0; i-- {
		frame := &vm.frames[i]
		function := frame.function
		instruction := frame.ip - 1
		fprintf(std::stderr(), "[line %d] in ",
			function.chunk.lines[instruction])
		if function.name == "" {
			fprintf(std::stderr(), "script\n")
		} else {
			fprintf(std::stderr(), "%s()\n", function.name)
		}
	}

	resetStack()
	return .RuntimeError
}

fn push(v: value::Value) {
	vm.stack[vm.stackTop] = v
	vm.stackTop++
}

fn pop(): value::Value {
	vm.stackTop--
	return vm.stack[vm.stackTop]
}

fn peek(distance: int): ^value::Value {
	return &vm.stack[vm.stackTop-1 - distance]
}

fn call(function: ^object::Function, argCount: uint): bool {
	if argCount != function.arity {
		runtimeError(sprintf("Expected %d arguments but got %d.", function.arity, argCount))
		return false
	}
	
	if vm.frameCount == FRAMES_MAX {
		runtimeError("Stack overflow.")
		return false
	}

	frame := &vm.frames[vm.frameCount]
	vm.frameCount++
	frame.function = function
	frame.ip = 0
	frame.slots = vm.stackTop - argCount - 1
	return true
}

fn callValue(callee: value::Value, argCount: uint): bool {
	if f := ^object::Function(callee); f != null {
		return call(f, argCount)
	}

	if f := ^object::NativeFunction(callee); f != null {
		result := f(argCount, vm.stack, vm.stackTop-argCount)
		vm.stackTop -= argCount + 1
		push(result)
		return true
	}

	runtimeError("Can only call functions and classes.")
	return false
}

fn init*() {
	resetStack()
	vm.globals = {}
	vm.globals["clock"] = object::NativeFunction(clock)
}

fn free*() {

}

fn readByte(frame: ^CallFrame): uint8 {
	b := frame.function.chunk.code[frame.ip]
	frame.ip++
	return b
}

fn readOpCode(frame: ^CallFrame): chunk::OpCode {
	return chunk::OpCode(readByte(frame))
}

fn readConstant(frame: ^CallFrame): value::Value {
	return frame.function.chunk.constants[readByte(frame)]
}

fn readShort(frame: ^CallFrame): uint16 {
	frame.ip += 2
	return (frame.function.chunk.code[frame.ip-2] << 8) |
	        frame.function.chunk.code[frame.ip-1]
}

fn binaryOp(op: uint): InterpretResult {
	if lhs, rhs := ^value::Number(peek(0)^), ^value::Number(peek(1)^)
	lhs == null && rhs == null {
		return runtimeError("Operands must be numbers.")
	}

	b := value::Number(pop())
	a := value::Number(pop())
	switch op {
	case 0: push(a - b)
	case 1: push(a * b)
	case 2:
		if b == 0 { return runtimeError("Division by zero.") }
		push(a / b)
	}

	return .Ok
}

fn comparisonOp(op: uint): InterpretResult {
	if lhs, rhs := ^value::Number(peek(0)^), ^value::Number(peek(1)^)
	lhs == null || rhs == null {
		return runtimeError("Operands must be numbers.")
	}

	b := value::Number(pop())
	a := value::Number(pop())
	switch op {
	case 0: push(value::Bool(a <  b))
	case 1: push(value::Bool(a >  b))
	}

	return .Ok
}

fn run(): InterpretResult {
	frame := &vm.frames[vm.frameCount - 1]

	for true {
		if common::DEBUG_TRACE_EXECUTION {
			printf(" ")
			for slot := 0; slot < vm.stackTop; slot++ {
				printf("[ ")
				vm.stack[slot].print()
				printf(" ]")
			}
			printf("\n")

			debug::disassembleInstruction(&frame.function.chunk, frame.ip)
		}

		switch ins := readOpCode(frame); ins {
		case .Constant: push(readConstant(frame))
		case .Nil: push(value::Nil {})
		case .True: push(value::Bool(true))
		case .False: push(value::Bool(false))
		case .Pop: pop()
		case .PopN:
			amt := readByte(frame)
			for i := 0; i < amt; i++ { pop() }

		case .GetGlobal:
			name := value::String(readConstant(frame))
			if !validkey(vm.globals, name) {
				return runtimeError(sprintf("Undefined variable '%s'.", name))
			}
			push(vm.globals[name])

		case .GetLocal:
			offset := readByte(frame)
			push(vm.stack[frame.slots+offset])

		case .DefineGlobal:
			name := value::String(readConstant(frame))
			vm.globals[name] = peek(0)^
			pop()

		case .SetGlobal:
			name := value::String(readConstant(frame))
			if !validkey(vm.globals, name) {
				return runtimeError(sprintf("Undefined variable '%s'.", name))
			}
			vm.globals[name] = peek(0)^

		case .SetLocal:
			offset := readByte(frame)
			vm.stack[frame.slots+offset] = peek(0)^

		case .Less: comparisonOp(0)
		case .Greater: comparisonOp(1)

		case .Equal:
			b, a := pop(), pop()
			push(value::Bool(a.equals(&b)))

		case .Add:
			b, a := pop(), pop()

			if lhs, rhs := ^value::String(b), ^value::String(a); lhs != null && rhs != null {
				push(lhs^ + rhs^)
			} else if lhs, rhs := ^value::Number(b), ^value::Number(a); lhs != null && rhs != null {
				push(lhs^ + rhs^)
			} else {
				return runtimeError("Operands must be two numbers or two strings.")
			}

		case .Subtract: if binaryOp(0) != .Ok { return .RuntimeError }
		case .Multiply: if binaryOp(1) != .Ok { return .RuntimeError }
		case .Divide: if binaryOp(2) != .Ok { return .RuntimeError }

		case .Negate:
			if n := ^value::Number(peek(0)^); n != null {
				return runtimeError("Operand must be a number.")
			}

			peek(0)^ = -value::Number(peek(0)^)

		case .Not: push(value::Bool(pop().isFalsey()))

		case .Print:
			pop().print()
			printf("\n")

		case .Jump:
			offset := readShort(frame)
			frame.ip += offset

		case .JumpIfFalse:
			offset := readShort(frame)
			if peek(0).isFalsey() { frame.ip += offset }

		case .Loop:
			offset := readShort(frame)
			frame.ip -= offset

		case .Call:
			argCount := readByte(frame)
			if !callValue(peek(argCount)^, argCount) {
				return .RuntimeError
			}
			frame = &vm.frames[vm.frameCount - 1]

		case .Return:
			result := pop()
			vm.frameCount--
			if vm.frameCount == 0 {
				pop()
				return .Ok
			}

			vm.stackTop = frame.slots
			push(result)
			frame = &vm.frames[vm.frameCount - 1]

		default: std::assert(false, "Unreachable")
		}
	}

	return .RuntimeError // unreachable
}

fn interpret*(source: str): InterpretResult {
	function := compiler::compile(source)
	if function == null { return .CompileError }
	
	push(function)
	call(function, 0)

	return run()
}
